import Paddle from './modules/paddle.js';import Ball from './modules/ball.js';import specs from './modules/specs.js';import Vec from './modules/vector.js';import Brick from './modules/brick.js';class Pong {  constructor(canvas) {    this._canvas = canvas;    this._context = canvas.getContext('2d');    this.fps = 60;    this.grid = new Vec(6, 8);    this.gridItems = [];    this.gridItemDone = 0;    this.mouseX = 0;    this.mouseY = 0;    this.paddle = new Paddle(Object.assign(specs.paddleSpecs, {      x: this._canvas.width / 2,      y: this._canvas.height - specs.paddleSpecs.offset,    }));    this.ball = new Ball(specs.ballSpecs);    this.init();  }  init() {    this.update();    this.onMouseMove();    this.makeGridEntities();  }  update() {    setInterval(() => {      this.draw();      this.moveBall();      this.collide();      this.ballBrickCollided();      this.resetBricks();    }, 1000 / this.fps);  }  draw() {    this._context.fillStyle = 'black';    this._context.fillRect(0, 0, this._canvas.width, this._canvas.height);    this.drawRect(this.paddle);    this.drawGrid();    this.drawCircle(this.ball);    this.__debugger__();  }  drawRect(rect) {    this._context.fillStyle = rect.color;    this._context.fillRect(        rect.pos.x,        rect.pos.y,        rect.size.x,        rect.size.y,    );  }  drawCircle(circle) {    this._context.fillStyle = circle.color;    this._context.beginPath();    this._context.arc(        circle.left,        circle.top,        circle.radius,        circle.startAngle,        circle.endAngle,        true,    );    this._context.fill();  }  drawGrid() {    this.gridItems.forEach(rect => rect.visible && this.drawRect(rect));  }  makeGridEntities() {    var rowsLength = this.grid.x;    var colsLength = this.grid.y;    for (var row = 0; row < rowsLength; row++) {      for (var col = 0; col < colsLength; col++) {        var brick = new Brick(Object.assign(specs.brick, {          x: specs.brick.width * col,          y: (specs.brick.height * row) + 3,        }));        brick.size.x -= 2;        brick.size.y -= 2;        this.gridItems.push(brick);      }    }  }  onMouseMove() {    this._canvas.addEventListener('mousemove', (event) => {      this.paddle.pos.x = event.offsetX - this.paddle.size.x / 2;      this.mouseX = event.offsetX;      this.mouseY = event.offsetY;      this.reset(this.mouseX, this.mouseY);    });  }  __debugger__() {    this._context.fillStyle = 'blue';    var {width, height} = specs.brick;    var col = Math.floor(this.mouseX / width);    var row = Math.floor(this.mouseY / height);    var index = col + (        this.grid.y * row    );    this._context.font = '17px sans-serif';    this._context.fillText(        `${col}, ${row}, ${index}`, this.mouseX, this.mouseY);  }  moveBall() {    this.ball.pos.x += this.ball.vel.x;    this.ball.pos.y += this.ball.vel.y;    if (this.ball.left <= 0 || this.ball.right > this._canvas.width) {      this.ball.vel.x = -this.ball.vel.x;    }    if (this.ball.top <= 0) {      this.ball.vel.y = -this.ball.vel.y;    }    if (this.ball.top > this._canvas.height) {      this.reset();    }  }  collide() {    if (this.ball.left > this.paddle.left &&        this.ball.right < this.paddle.right &&        this.ball.bottom > this.paddle.top    ) {      this.ball.vel.y = -this.ball.vel.y;      var paddleCenter = this.paddle.pos.x + (          this.paddle.size.x / 2      );      var collisionPointFromCenter = this.ball.pos.x - paddleCenter;      this.ball.vel.x = collisionPointFromCenter * this.ball.drag;    }  }  reset(x = this._canvas.width / 2 , y = this._canvas.height / 2) {    this.ball.pos.x = x;    this.ball.pos.y = y;    this.ball.vel.x = 3;    this.ball.vel.y = 5;  }  resetBricks() {    if (this.gridItemDone === this.gridItems.length) {      this.gridItems = this.gridItems.map(brick => {        brick.visible = true;        return brick;      });    }  }  ballBrickCollided() {    var {width, height} = specs.brick;    var col = Math.floor(this.ball.pos.x / width);    var row = Math.floor(this.ball.pos.y / height);    var index = col + (        this.grid.y * row    );    var brickAtGrid = this.gridItems[index];    if (index >= 0        && index < this.grid.x * this.grid.y &&        brickAtGrid.visible !== false    ) {      brickAtGrid.visible = false;      var ballX = Math.floor(this.ball.pos.x);      var brickLeftReference = brickAtGrid.left + 5;      var brickRightReference = brickAtGrid.right - 5;      if (brickLeftReference >= ballX) {        this.ball.vel.x *= -1;      }      if (brickRightReference < ballX) {        this.ball.vel.x *= -1;      }      this.ball.vel.y *= -1;      this.gridItemDone++;    }  }}const canvas = document.querySelector('#canvas');const pong = new Pong(canvas);window.pong = pong;